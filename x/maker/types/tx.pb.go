// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: merlion/maker/v1/tx.proto

package types

import (
	context "context"
	fmt "fmt"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/gogo/protobuf/gogoproto"
	grpc1 "github.com/gogo/protobuf/grpc"
	proto "github.com/gogo/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MsgMintBySwap represents a message to mint Mer stablecoins by swapping.
type MsgMintBySwap struct {
	Sender       string     `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty" yaml:"sender"`
	To           string     `protobuf:"bytes,2,opt,name=to,proto3" json:"to,omitempty" yaml:"to"`
	FullBacking  bool       `protobuf:"varint,3,opt,name=full_backing,json=fullBacking,proto3" json:"full_backing,omitempty" yaml:"full_backing"`
	BackingInMax types.Coin `protobuf:"bytes,4,opt,name=backing_in_max,json=backingInMax,proto3" json:"backing_in_max" yaml:"backing_in_max"`
	LionInMax    types.Coin `protobuf:"bytes,5,opt,name=lion_in_max,json=lionInMax,proto3" json:"lion_in_max" yaml:"lion_in_max"`
	MintOutMin   types.Coin `protobuf:"bytes,6,opt,name=mint_out_min,json=mintOutMin,proto3" json:"mint_out_min" yaml:"mint_out_min"`
}

func (m *MsgMintBySwap) Reset()         { *m = MsgMintBySwap{} }
func (m *MsgMintBySwap) String() string { return proto.CompactTextString(m) }
func (*MsgMintBySwap) ProtoMessage()    {}
func (*MsgMintBySwap) Descriptor() ([]byte, []int) {
	return fileDescriptor_2797be2e51038e24, []int{0}
}
func (m *MsgMintBySwap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgMintBySwap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgMintBySwap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgMintBySwap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgMintBySwap.Merge(m, src)
}
func (m *MsgMintBySwap) XXX_Size() int {
	return m.Size()
}
func (m *MsgMintBySwap) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgMintBySwap.DiscardUnknown(m)
}

var xxx_messageInfo_MsgMintBySwap proto.InternalMessageInfo

// MsgMintBySwapResponse defines the Msg/MintBySwap response type.
type MsgMintBySwapResponse struct {
	BackingIn types.Coin `protobuf:"bytes,1,opt,name=backing_in,json=backingIn,proto3" json:"backing_in" yaml:"backing_in"`
	LionIn    types.Coin `protobuf:"bytes,2,opt,name=lion_in,json=lionIn,proto3" json:"lion_in" yaml:"lion_in"`
	MintOut   types.Coin `protobuf:"bytes,3,opt,name=mint_out,json=mintOut,proto3" json:"mint_out" yaml:"mint_out"`
	MintFee   types.Coin `protobuf:"bytes,4,opt,name=mint_fee,json=mintFee,proto3" json:"mint_fee" yaml:"mint_fee"`
}

func (m *MsgMintBySwapResponse) Reset()         { *m = MsgMintBySwapResponse{} }
func (m *MsgMintBySwapResponse) String() string { return proto.CompactTextString(m) }
func (*MsgMintBySwapResponse) ProtoMessage()    {}
func (*MsgMintBySwapResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2797be2e51038e24, []int{1}
}
func (m *MsgMintBySwapResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgMintBySwapResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgMintBySwapResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgMintBySwapResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgMintBySwapResponse.Merge(m, src)
}
func (m *MsgMintBySwapResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgMintBySwapResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgMintBySwapResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgMintBySwapResponse proto.InternalMessageInfo

func (m *MsgMintBySwapResponse) GetBackingIn() types.Coin {
	if m != nil {
		return m.BackingIn
	}
	return types.Coin{}
}

func (m *MsgMintBySwapResponse) GetLionIn() types.Coin {
	if m != nil {
		return m.LionIn
	}
	return types.Coin{}
}

func (m *MsgMintBySwapResponse) GetMintOut() types.Coin {
	if m != nil {
		return m.MintOut
	}
	return types.Coin{}
}

func (m *MsgMintBySwapResponse) GetMintFee() types.Coin {
	if m != nil {
		return m.MintFee
	}
	return types.Coin{}
}

// MsgBurnBySwap represents a message to burn Mer stablecoins by swapping.
type MsgBurnBySwap struct {
	Sender        string     `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty" yaml:"sender"`
	To            string     `protobuf:"bytes,2,opt,name=to,proto3" json:"to,omitempty" yaml:"to"`
	BurnIn        types.Coin `protobuf:"bytes,3,opt,name=burn_in,json=burnIn,proto3" json:"burn_in" yaml:"burn_in"`
	BackingOutMin types.Coin `protobuf:"bytes,4,opt,name=backing_out_min,json=backingOutMin,proto3" json:"backing_out_min" yaml:"backing_out_min"`
	LionOutMin    types.Coin `protobuf:"bytes,5,opt,name=lion_out_min,json=lionOutMin,proto3" json:"lion_out_min" yaml:"lion_out_min"`
}

func (m *MsgBurnBySwap) Reset()         { *m = MsgBurnBySwap{} }
func (m *MsgBurnBySwap) String() string { return proto.CompactTextString(m) }
func (*MsgBurnBySwap) ProtoMessage()    {}
func (*MsgBurnBySwap) Descriptor() ([]byte, []int) {
	return fileDescriptor_2797be2e51038e24, []int{2}
}
func (m *MsgBurnBySwap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBurnBySwap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBurnBySwap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBurnBySwap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBurnBySwap.Merge(m, src)
}
func (m *MsgBurnBySwap) XXX_Size() int {
	return m.Size()
}
func (m *MsgBurnBySwap) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBurnBySwap.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBurnBySwap proto.InternalMessageInfo

// MsgBurnBySwapResponse defines the Msg/BurnBySwap response type.
type MsgBurnBySwapResponse struct {
	BurnFee    types.Coin `protobuf:"bytes,1,opt,name=burn_fee,json=burnFee,proto3" json:"burn_fee" yaml:"burn_fee"`
	BackingOut types.Coin `protobuf:"bytes,2,opt,name=backing_out,json=backingOut,proto3" json:"backing_out" yaml:"backing_out"`
	LionOut    types.Coin `protobuf:"bytes,3,opt,name=lion_out,json=lionOut,proto3" json:"lion_out" yaml:"lion_out"`
}

func (m *MsgBurnBySwapResponse) Reset()         { *m = MsgBurnBySwapResponse{} }
func (m *MsgBurnBySwapResponse) String() string { return proto.CompactTextString(m) }
func (*MsgBurnBySwapResponse) ProtoMessage()    {}
func (*MsgBurnBySwapResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2797be2e51038e24, []int{3}
}
func (m *MsgBurnBySwapResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBurnBySwapResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBurnBySwapResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBurnBySwapResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBurnBySwapResponse.Merge(m, src)
}
func (m *MsgBurnBySwapResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgBurnBySwapResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBurnBySwapResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBurnBySwapResponse proto.InternalMessageInfo

func (m *MsgBurnBySwapResponse) GetBurnFee() types.Coin {
	if m != nil {
		return m.BurnFee
	}
	return types.Coin{}
}

func (m *MsgBurnBySwapResponse) GetBackingOut() types.Coin {
	if m != nil {
		return m.BackingOut
	}
	return types.Coin{}
}

func (m *MsgBurnBySwapResponse) GetLionOut() types.Coin {
	if m != nil {
		return m.LionOut
	}
	return types.Coin{}
}

// MsgBuyBacking represents a message to buy strong-backing assets.
type MsgBuyBacking struct {
	Sender        string     `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty" yaml:"sender"`
	To            string     `protobuf:"bytes,2,opt,name=to,proto3" json:"to,omitempty" yaml:"to"`
	LionIn        types.Coin `protobuf:"bytes,3,opt,name=lion_in,json=lionIn,proto3" json:"lion_in" yaml:"lion_in"`
	BackingOutMin types.Coin `protobuf:"bytes,4,opt,name=backing_out_min,json=backingOutMin,proto3" json:"backing_out_min" yaml:"backing_out_min"`
}

func (m *MsgBuyBacking) Reset()         { *m = MsgBuyBacking{} }
func (m *MsgBuyBacking) String() string { return proto.CompactTextString(m) }
func (*MsgBuyBacking) ProtoMessage()    {}
func (*MsgBuyBacking) Descriptor() ([]byte, []int) {
	return fileDescriptor_2797be2e51038e24, []int{4}
}
func (m *MsgBuyBacking) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBuyBacking) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBuyBacking.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBuyBacking) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBuyBacking.Merge(m, src)
}
func (m *MsgBuyBacking) XXX_Size() int {
	return m.Size()
}
func (m *MsgBuyBacking) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBuyBacking.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBuyBacking proto.InternalMessageInfo

// MsgBuyBackingResponse defines the Msg/BuyBacking response type.
type MsgBuyBackingResponse struct {
	BackingOut types.Coin `protobuf:"bytes,1,opt,name=backing_out,json=backingOut,proto3" json:"backing_out" yaml:"backing_out"`
}

func (m *MsgBuyBackingResponse) Reset()         { *m = MsgBuyBackingResponse{} }
func (m *MsgBuyBackingResponse) String() string { return proto.CompactTextString(m) }
func (*MsgBuyBackingResponse) ProtoMessage()    {}
func (*MsgBuyBackingResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2797be2e51038e24, []int{5}
}
func (m *MsgBuyBackingResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBuyBackingResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBuyBackingResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBuyBackingResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBuyBackingResponse.Merge(m, src)
}
func (m *MsgBuyBackingResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgBuyBackingResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBuyBackingResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBuyBackingResponse proto.InternalMessageInfo

func (m *MsgBuyBackingResponse) GetBackingOut() types.Coin {
	if m != nil {
		return m.BackingOut
	}
	return types.Coin{}
}

// MsgSellBacking represents a message to sell strong-backing
// assets.
type MsgSellBacking struct {
	Sender     string     `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty" yaml:"sender"`
	To         string     `protobuf:"bytes,2,opt,name=to,proto3" json:"to,omitempty" yaml:"to"`
	BackingIn  types.Coin `protobuf:"bytes,3,opt,name=backing_in,json=backingIn,proto3" json:"backing_in" yaml:"backing_in"`
	LionOutMin types.Coin `protobuf:"bytes,4,opt,name=lion_out_min,json=lionOutMin,proto3" json:"lion_out_min" yaml:"lion_out_min"`
}

func (m *MsgSellBacking) Reset()         { *m = MsgSellBacking{} }
func (m *MsgSellBacking) String() string { return proto.CompactTextString(m) }
func (*MsgSellBacking) ProtoMessage()    {}
func (*MsgSellBacking) Descriptor() ([]byte, []int) {
	return fileDescriptor_2797be2e51038e24, []int{6}
}
func (m *MsgSellBacking) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSellBacking) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSellBacking.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSellBacking) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSellBacking.Merge(m, src)
}
func (m *MsgSellBacking) XXX_Size() int {
	return m.Size()
}
func (m *MsgSellBacking) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSellBacking.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSellBacking proto.InternalMessageInfo

// MsgSellBackingResponse defines the Msg/SellBacking response type.
type MsgSellBackingResponse struct {
	LionOut types.Coin `protobuf:"bytes,1,opt,name=lion_out,json=lionOut,proto3" json:"lion_out" yaml:"lion_out"`
}

func (m *MsgSellBackingResponse) Reset()         { *m = MsgSellBackingResponse{} }
func (m *MsgSellBackingResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSellBackingResponse) ProtoMessage()    {}
func (*MsgSellBackingResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2797be2e51038e24, []int{7}
}
func (m *MsgSellBackingResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSellBackingResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSellBackingResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSellBackingResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSellBackingResponse.Merge(m, src)
}
func (m *MsgSellBackingResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSellBackingResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSellBackingResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSellBackingResponse proto.InternalMessageInfo

func (m *MsgSellBackingResponse) GetLionOut() types.Coin {
	if m != nil {
		return m.LionOut
	}
	return types.Coin{}
}

// MsgMintByCollateral represents a message to mint Mer stablecoins by locking
// collateral.
type MsgMintByCollateral struct {
	Sender          string                                 `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty" yaml:"sender"`
	To              string                                 `protobuf:"bytes,2,opt,name=to,proto3" json:"to,omitempty" yaml:"to"`
	CollateralDenom string                                 `protobuf:"bytes,3,opt,name=collateral_denom,json=collateralDenom,proto3" json:"collateral_denom,omitempty" yaml:"collateral_denom"`
	Ltv             github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,4,opt,name=ltv,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"ltv" yaml:"ltv"`
	MintOutMin      types.Coin                             `protobuf:"bytes,5,opt,name=mint_out_min,json=mintOutMin,proto3" json:"mint_out_min" yaml:"mint_out_min"`
}

func (m *MsgMintByCollateral) Reset()         { *m = MsgMintByCollateral{} }
func (m *MsgMintByCollateral) String() string { return proto.CompactTextString(m) }
func (*MsgMintByCollateral) ProtoMessage()    {}
func (*MsgMintByCollateral) Descriptor() ([]byte, []int) {
	return fileDescriptor_2797be2e51038e24, []int{8}
}
func (m *MsgMintByCollateral) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgMintByCollateral) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgMintByCollateral.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgMintByCollateral) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgMintByCollateral.Merge(m, src)
}
func (m *MsgMintByCollateral) XXX_Size() int {
	return m.Size()
}
func (m *MsgMintByCollateral) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgMintByCollateral.DiscardUnknown(m)
}

var xxx_messageInfo_MsgMintByCollateral proto.InternalMessageInfo

// MsgMintByCollateralResponse defines the Msg/MintByCollateral response type.
type MsgMintByCollateralResponse struct {
	LionIn  types.Coin `protobuf:"bytes,1,opt,name=lion_in,json=lionIn,proto3" json:"lion_in" yaml:"lion_in"`
	MintOut types.Coin `protobuf:"bytes,2,opt,name=mint_out,json=mintOut,proto3" json:"mint_out" yaml:"mint_out"`
	MintFee types.Coin `protobuf:"bytes,3,opt,name=mint_fee,json=mintFee,proto3" json:"mint_fee" yaml:"mint_fee"`
}

func (m *MsgMintByCollateralResponse) Reset()         { *m = MsgMintByCollateralResponse{} }
func (m *MsgMintByCollateralResponse) String() string { return proto.CompactTextString(m) }
func (*MsgMintByCollateralResponse) ProtoMessage()    {}
func (*MsgMintByCollateralResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2797be2e51038e24, []int{9}
}
func (m *MsgMintByCollateralResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgMintByCollateralResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgMintByCollateralResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgMintByCollateralResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgMintByCollateralResponse.Merge(m, src)
}
func (m *MsgMintByCollateralResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgMintByCollateralResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgMintByCollateralResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgMintByCollateralResponse proto.InternalMessageInfo

func (m *MsgMintByCollateralResponse) GetLionIn() types.Coin {
	if m != nil {
		return m.LionIn
	}
	return types.Coin{}
}

func (m *MsgMintByCollateralResponse) GetMintOut() types.Coin {
	if m != nil {
		return m.MintOut
	}
	return types.Coin{}
}

func (m *MsgMintByCollateralResponse) GetMintFee() types.Coin {
	if m != nil {
		return m.MintFee
	}
	return types.Coin{}
}

// MsgBurnByCollateral represents a message to burn Mer stablecoins by unlocking
// collateral.
type MsgBurnByCollateral struct {
	Sender          string     `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty" yaml:"sender"`
	CollateralDenom string     `protobuf:"bytes,2,opt,name=collateral_denom,json=collateralDenom,proto3" json:"collateral_denom,omitempty" yaml:"collateral_denom"`
	RepayInMax      types.Coin `protobuf:"bytes,3,opt,name=repay_in_max,json=repayInMax,proto3" json:"repay_in_max" yaml:"repay_in_max"`
}

func (m *MsgBurnByCollateral) Reset()         { *m = MsgBurnByCollateral{} }
func (m *MsgBurnByCollateral) String() string { return proto.CompactTextString(m) }
func (*MsgBurnByCollateral) ProtoMessage()    {}
func (*MsgBurnByCollateral) Descriptor() ([]byte, []int) {
	return fileDescriptor_2797be2e51038e24, []int{10}
}
func (m *MsgBurnByCollateral) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBurnByCollateral) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBurnByCollateral.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBurnByCollateral) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBurnByCollateral.Merge(m, src)
}
func (m *MsgBurnByCollateral) XXX_Size() int {
	return m.Size()
}
func (m *MsgBurnByCollateral) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBurnByCollateral.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBurnByCollateral proto.InternalMessageInfo

// MsgBurnByCollateralResponse defines the Msg/BurnByCollateral response type.
type MsgBurnByCollateralResponse struct {
	RepayIn types.Coin `protobuf:"bytes,1,opt,name=repay_in,json=repayIn,proto3" json:"repay_in" yaml:"repay_in"`
}

func (m *MsgBurnByCollateralResponse) Reset()         { *m = MsgBurnByCollateralResponse{} }
func (m *MsgBurnByCollateralResponse) String() string { return proto.CompactTextString(m) }
func (*MsgBurnByCollateralResponse) ProtoMessage()    {}
func (*MsgBurnByCollateralResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2797be2e51038e24, []int{11}
}
func (m *MsgBurnByCollateralResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBurnByCollateralResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBurnByCollateralResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBurnByCollateralResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBurnByCollateralResponse.Merge(m, src)
}
func (m *MsgBurnByCollateralResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgBurnByCollateralResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBurnByCollateralResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBurnByCollateralResponse proto.InternalMessageInfo

func (m *MsgBurnByCollateralResponse) GetRepayIn() types.Coin {
	if m != nil {
		return m.RepayIn
	}
	return types.Coin{}
}

// MsgDepositCollateral represents a message to deposit collateral assets.
type MsgDepositCollateral struct {
	Sender     string     `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty" yaml:"sender"`
	To         string     `protobuf:"bytes,2,opt,name=to,proto3" json:"to,omitempty" yaml:"to"`
	Collateral types.Coin `protobuf:"bytes,3,opt,name=collateral,proto3" json:"collateral" yaml:"collateral"`
}

func (m *MsgDepositCollateral) Reset()         { *m = MsgDepositCollateral{} }
func (m *MsgDepositCollateral) String() string { return proto.CompactTextString(m) }
func (*MsgDepositCollateral) ProtoMessage()    {}
func (*MsgDepositCollateral) Descriptor() ([]byte, []int) {
	return fileDescriptor_2797be2e51038e24, []int{12}
}
func (m *MsgDepositCollateral) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDepositCollateral) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDepositCollateral.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDepositCollateral) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDepositCollateral.Merge(m, src)
}
func (m *MsgDepositCollateral) XXX_Size() int {
	return m.Size()
}
func (m *MsgDepositCollateral) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDepositCollateral.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDepositCollateral proto.InternalMessageInfo

// MsgDepositCollateralResponse defines the Msg/DepositCollateral response type.
type MsgDepositCollateralResponse struct {
}

func (m *MsgDepositCollateralResponse) Reset()         { *m = MsgDepositCollateralResponse{} }
func (m *MsgDepositCollateralResponse) String() string { return proto.CompactTextString(m) }
func (*MsgDepositCollateralResponse) ProtoMessage()    {}
func (*MsgDepositCollateralResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2797be2e51038e24, []int{13}
}
func (m *MsgDepositCollateralResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDepositCollateralResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDepositCollateralResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDepositCollateralResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDepositCollateralResponse.Merge(m, src)
}
func (m *MsgDepositCollateralResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgDepositCollateralResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDepositCollateralResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDepositCollateralResponse proto.InternalMessageInfo

// MsgRedeemCollateral represents a message to redeem collateral assets.
type MsgRedeemCollateral struct {
	Sender     string     `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty" yaml:"sender"`
	To         string     `protobuf:"bytes,2,opt,name=to,proto3" json:"to,omitempty" yaml:"to"`
	Collateral types.Coin `protobuf:"bytes,3,opt,name=collateral,proto3" json:"collateral" yaml:"collateral"`
}

func (m *MsgRedeemCollateral) Reset()         { *m = MsgRedeemCollateral{} }
func (m *MsgRedeemCollateral) String() string { return proto.CompactTextString(m) }
func (*MsgRedeemCollateral) ProtoMessage()    {}
func (*MsgRedeemCollateral) Descriptor() ([]byte, []int) {
	return fileDescriptor_2797be2e51038e24, []int{14}
}
func (m *MsgRedeemCollateral) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRedeemCollateral) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRedeemCollateral.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRedeemCollateral) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRedeemCollateral.Merge(m, src)
}
func (m *MsgRedeemCollateral) XXX_Size() int {
	return m.Size()
}
func (m *MsgRedeemCollateral) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRedeemCollateral.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRedeemCollateral proto.InternalMessageInfo

// MsgRedeemCollateralResponse defines the Msg/RedeemCollateral response type.
type MsgRedeemCollateralResponse struct {
}

func (m *MsgRedeemCollateralResponse) Reset()         { *m = MsgRedeemCollateralResponse{} }
func (m *MsgRedeemCollateralResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRedeemCollateralResponse) ProtoMessage()    {}
func (*MsgRedeemCollateralResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2797be2e51038e24, []int{15}
}
func (m *MsgRedeemCollateralResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRedeemCollateralResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRedeemCollateralResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRedeemCollateralResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRedeemCollateralResponse.Merge(m, src)
}
func (m *MsgRedeemCollateralResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRedeemCollateralResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRedeemCollateralResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRedeemCollateralResponse proto.InternalMessageInfo

// MsgLiquidateCollateral represents a message to liquidates collateral assets.
type MsgLiquidateCollateral struct {
	Sender     string     `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty" yaml:"sender"`
	To         string     `protobuf:"bytes,2,opt,name=to,proto3" json:"to,omitempty" yaml:"to"`
	Debtor     string     `protobuf:"bytes,3,opt,name=debtor,proto3" json:"debtor,omitempty" yaml:"to"`
	Collateral types.Coin `protobuf:"bytes,4,opt,name=collateral,proto3" json:"collateral" yaml:"collateral"`
}

func (m *MsgLiquidateCollateral) Reset()         { *m = MsgLiquidateCollateral{} }
func (m *MsgLiquidateCollateral) String() string { return proto.CompactTextString(m) }
func (*MsgLiquidateCollateral) ProtoMessage()    {}
func (*MsgLiquidateCollateral) Descriptor() ([]byte, []int) {
	return fileDescriptor_2797be2e51038e24, []int{16}
}
func (m *MsgLiquidateCollateral) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgLiquidateCollateral) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgLiquidateCollateral.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgLiquidateCollateral) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgLiquidateCollateral.Merge(m, src)
}
func (m *MsgLiquidateCollateral) XXX_Size() int {
	return m.Size()
}
func (m *MsgLiquidateCollateral) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgLiquidateCollateral.DiscardUnknown(m)
}

var xxx_messageInfo_MsgLiquidateCollateral proto.InternalMessageInfo

// MsgLiquidateCollateralResponse defines the Msg/LiquidateCollateral response
// type.
type MsgLiquidateCollateralResponse struct {
	RepayIn       types.Coin `protobuf:"bytes,1,opt,name=repay_in,json=repayIn,proto3" json:"repay_in" yaml:"repay_in"`
	CollateralOut types.Coin `protobuf:"bytes,2,opt,name=collateral_out,json=collateralOut,proto3" json:"collateral_out" yaml:"collateral_out"`
}

func (m *MsgLiquidateCollateralResponse) Reset()         { *m = MsgLiquidateCollateralResponse{} }
func (m *MsgLiquidateCollateralResponse) String() string { return proto.CompactTextString(m) }
func (*MsgLiquidateCollateralResponse) ProtoMessage()    {}
func (*MsgLiquidateCollateralResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2797be2e51038e24, []int{17}
}
func (m *MsgLiquidateCollateralResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgLiquidateCollateralResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgLiquidateCollateralResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgLiquidateCollateralResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgLiquidateCollateralResponse.Merge(m, src)
}
func (m *MsgLiquidateCollateralResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgLiquidateCollateralResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgLiquidateCollateralResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgLiquidateCollateralResponse proto.InternalMessageInfo

func (m *MsgLiquidateCollateralResponse) GetRepayIn() types.Coin {
	if m != nil {
		return m.RepayIn
	}
	return types.Coin{}
}

func (m *MsgLiquidateCollateralResponse) GetCollateralOut() types.Coin {
	if m != nil {
		return m.CollateralOut
	}
	return types.Coin{}
}

func init() {
	proto.RegisterType((*MsgMintBySwap)(nil), "merlion.maker.v1.MsgMintBySwap")
	proto.RegisterType((*MsgMintBySwapResponse)(nil), "merlion.maker.v1.MsgMintBySwapResponse")
	proto.RegisterType((*MsgBurnBySwap)(nil), "merlion.maker.v1.MsgBurnBySwap")
	proto.RegisterType((*MsgBurnBySwapResponse)(nil), "merlion.maker.v1.MsgBurnBySwapResponse")
	proto.RegisterType((*MsgBuyBacking)(nil), "merlion.maker.v1.MsgBuyBacking")
	proto.RegisterType((*MsgBuyBackingResponse)(nil), "merlion.maker.v1.MsgBuyBackingResponse")
	proto.RegisterType((*MsgSellBacking)(nil), "merlion.maker.v1.MsgSellBacking")
	proto.RegisterType((*MsgSellBackingResponse)(nil), "merlion.maker.v1.MsgSellBackingResponse")
	proto.RegisterType((*MsgMintByCollateral)(nil), "merlion.maker.v1.MsgMintByCollateral")
	proto.RegisterType((*MsgMintByCollateralResponse)(nil), "merlion.maker.v1.MsgMintByCollateralResponse")
	proto.RegisterType((*MsgBurnByCollateral)(nil), "merlion.maker.v1.MsgBurnByCollateral")
	proto.RegisterType((*MsgBurnByCollateralResponse)(nil), "merlion.maker.v1.MsgBurnByCollateralResponse")
	proto.RegisterType((*MsgDepositCollateral)(nil), "merlion.maker.v1.MsgDepositCollateral")
	proto.RegisterType((*MsgDepositCollateralResponse)(nil), "merlion.maker.v1.MsgDepositCollateralResponse")
	proto.RegisterType((*MsgRedeemCollateral)(nil), "merlion.maker.v1.MsgRedeemCollateral")
	proto.RegisterType((*MsgRedeemCollateralResponse)(nil), "merlion.maker.v1.MsgRedeemCollateralResponse")
	proto.RegisterType((*MsgLiquidateCollateral)(nil), "merlion.maker.v1.MsgLiquidateCollateral")
	proto.RegisterType((*MsgLiquidateCollateralResponse)(nil), "merlion.maker.v1.MsgLiquidateCollateralResponse")
}

func init() { proto.RegisterFile("merlion/maker/v1/tx.proto", fileDescriptor_2797be2e51038e24) }

var fileDescriptor_2797be2e51038e24 = []byte{
	// 1297 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x58, 0x4d, 0x6f, 0xe3, 0x54,
	0x17, 0x8e, 0x93, 0x36, 0x6d, 0x4e, 0xbf, 0xdd, 0x99, 0x7e, 0xa4, 0xd3, 0xa4, 0xef, 0x7d, 0xd5,
	0x4e, 0x2a, 0x54, 0x9b, 0x0e, 0xbb, 0x8a, 0x55, 0xa6, 0x2a, 0x9a, 0x11, 0x61, 0xa4, 0x5b, 0x40,
	0x23, 0x16, 0x44, 0x4e, 0x72, 0x1b, 0xac, 0x26, 0xbe, 0x21, 0x76, 0x4a, 0xc3, 0x0a, 0x10, 0x12,
	0x6c, 0x90, 0x10, 0xb3, 0x01, 0x89, 0xc5, 0x2c, 0xf8, 0x01, 0xf3, 0x0f, 0x60, 0x39, 0xcb, 0x4a,
	0x48, 0x08, 0x81, 0x14, 0xa1, 0x96, 0x05, 0x48, 0xac, 0xf2, 0x0b, 0x90, 0xaf, 0xaf, 0xed, 0x1b,
	0xc7, 0xf9, 0x9a, 0x49, 0x16, 0xac, 0x12, 0x5f, 0x9f, 0x73, 0xfc, 0x9c, 0xe7, 0x3c, 0xe7, 0x9e,
	0x6b, 0xc3, 0x66, 0x95, 0xd4, 0x2b, 0x3a, 0x35, 0xd4, 0xaa, 0x76, 0x4e, 0xea, 0xea, 0xc5, 0xa1,
	0x6a, 0x5d, 0x2a, 0xb5, 0x3a, 0xb5, 0xa8, 0xbc, 0xcc, 0x6f, 0x29, 0xec, 0x96, 0x72, 0x71, 0x98,
	0xbc, 0x53, 0xa6, 0xb4, 0x5c, 0x21, 0xaa, 0x56, 0xd3, 0x55, 0xcd, 0x30, 0xa8, 0xa5, 0x59, 0x3a,
	0x35, 0x4c, 0xc7, 0x3e, 0x79, 0xab, 0x4c, 0xcb, 0x94, 0xfd, 0x55, 0xed, 0x7f, 0x7c, 0x35, 0x55,
	0xa4, 0x66, 0x95, 0x9a, 0x6a, 0x41, 0x33, 0x89, 0x7a, 0x71, 0x58, 0x20, 0x96, 0x76, 0xa8, 0x16,
	0xa9, 0x6e, 0x38, 0xf7, 0xd1, 0xb3, 0x18, 0x2c, 0xe4, 0xcc, 0x72, 0x4e, 0x37, 0xac, 0x6c, 0xf3,
	0xf4, 0x23, 0xad, 0x26, 0xef, 0x43, 0xdc, 0x24, 0x46, 0x89, 0xd4, 0x37, 0xa4, 0x1d, 0x29, 0x93,
	0xc8, 0xae, 0xb4, 0x5b, 0xe9, 0x85, 0xa6, 0x56, 0xad, 0x1c, 0x21, 0x67, 0x1d, 0x61, 0x6e, 0x20,
	0x6f, 0x43, 0xd4, 0xa2, 0x1b, 0x51, 0x66, 0xb6, 0xd0, 0x6e, 0xa5, 0x13, 0x8e, 0x99, 0x45, 0x11,
	0x8e, 0x5a, 0x54, 0x3e, 0x82, 0xf9, 0xb3, 0x46, 0xa5, 0x92, 0x2f, 0x68, 0xc5, 0x73, 0xdd, 0x28,
	0x6f, 0xc4, 0x76, 0xa4, 0xcc, 0x6c, 0x76, 0xbd, 0xdd, 0x4a, 0xaf, 0x3a, 0x86, 0xe2, 0x5d, 0x84,
	0xe7, 0xec, 0xcb, 0xac, 0x73, 0x25, 0xbf, 0x0f, 0x8b, 0xfc, 0x46, 0x5e, 0x37, 0xf2, 0x55, 0xed,
	0x72, 0x63, 0x6a, 0x47, 0xca, 0xcc, 0xdd, 0xdb, 0x54, 0x9c, 0x84, 0x14, 0x3b, 0x21, 0x85, 0x27,
	0xa4, 0xdc, 0xa7, 0xba, 0x91, 0xdd, 0x7e, 0xde, 0x4a, 0x47, 0xda, 0xad, 0xf4, 0x6d, 0x27, 0x78,
	0xa7, 0x3b, 0xc2, 0xf3, 0x7c, 0xe1, 0x81, 0x91, 0xd3, 0x2e, 0xe5, 0x77, 0x60, 0xce, 0x26, 0xd7,
	0x0d, 0x3e, 0x3d, 0x28, 0x78, 0x92, 0x07, 0x97, 0x9d, 0xe0, 0x82, 0x2f, 0xc2, 0x09, 0xfb, 0xca,
	0x09, 0xfb, 0x18, 0xe6, 0xab, 0xba, 0x61, 0xe5, 0x69, 0xc3, 0xca, 0x57, 0x75, 0x63, 0x23, 0x3e,
	0x28, 0xee, 0x16, 0x8f, 0xcb, 0x19, 0x11, 0x9d, 0x11, 0x06, 0xfb, 0xf2, 0x51, 0xc3, 0xca, 0xe9,
	0xc6, 0xd1, 0xec, 0x97, 0x4f, 0xd3, 0x91, 0xbf, 0x9e, 0xa6, 0x23, 0xe8, 0x97, 0x28, 0xdc, 0xee,
	0x28, 0x19, 0x26, 0x66, 0x8d, 0x1a, 0x26, 0x91, 0x4f, 0x01, 0xfc, 0xac, 0x59, 0xf9, 0xfa, 0x3e,
	0x7b, 0x93, 0x3f, 0x7b, 0x25, 0x48, 0x18, 0xc2, 0x09, 0x8f, 0x2c, 0xf9, 0x21, 0xcc, 0xf0, 0x6c,
	0x59, 0xa5, 0xfb, 0x46, 0x5c, 0xe3, 0x11, 0x17, 0x3b, 0x58, 0x42, 0x38, 0xee, 0x30, 0x24, 0xe7,
	0x60, 0xd6, 0xcd, 0x90, 0xa9, 0xa1, 0x6f, 0xb0, 0x75, 0x1e, 0x6c, 0xa9, 0x93, 0x1a, 0x84, 0x67,
	0x38, 0x2d, 0x5e, 0xb8, 0x33, 0x42, 0x06, 0xcb, 0x23, 0x2c, 0xdc, 0x19, 0x21, 0x3c, 0xdc, 0x09,
	0x21, 0xe8, 0x9f, 0x28, 0xeb, 0x85, 0x6c, 0xa3, 0x6e, 0x8c, 0xbd, 0x17, 0x1e, 0xc2, 0x4c, 0xa1,
	0x51, 0x67, 0x2c, 0xc6, 0x46, 0x64, 0x91, 0xfb, 0x21, 0x1c, 0xb7, 0xff, 0x3d, 0x30, 0x64, 0x0d,
	0x96, 0xdc, 0x5a, 0xb9, 0x3a, 0x1b, 0x98, 0x7d, 0x8a, 0xc7, 0x5c, 0xeb, 0xac, 0xb5, 0x27, 0xb5,
	0x05, 0xbe, 0xe2, 0xa8, 0xcd, 0xd6, 0x31, 0x2b, 0x9e, 0x1b, 0x7f, 0x7a, 0x44, 0x1d, 0x8b, 0xce,
	0x08, 0x83, 0x7d, 0xd9, 0xa5, 0xe3, 0xaf, 0x1c, 0x1d, 0xfb, 0x74, 0x7b, 0x3a, 0xce, 0xc1, 0x2c,
	0x4b, 0xda, 0xae, 0xab, 0x34, 0x62, 0x5d, 0x5d, 0x47, 0x84, 0x19, 0xe1, 0x27, 0x84, 0xc8, 0xef,
	0xc2, 0x9c, 0x90, 0xef, 0x60, 0x15, 0x07, 0x7a, 0x5d, 0xf0, 0x45, 0x18, 0x7c, 0x9e, 0x6c, 0x98,
	0x6e, 0x9e, 0x23, 0xab, 0xd9, 0x75, 0x44, 0x78, 0x86, 0x93, 0x83, 0xbe, 0x71, 0xe5, 0xd7, 0x74,
	0x37, 0xc1, 0xb1, 0xca, 0xcf, 0x6d, 0xe2, 0xd8, 0xcb, 0x36, 0xf1, 0xe4, 0xe5, 0x27, 0x88, 0x84,
	0x72, 0x8d, 0xb8, 0x9c, 0x78, 0x1a, 0x09, 0x14, 0x55, 0x1a, 0x53, 0x51, 0xd1, 0x93, 0x28, 0x2c,
	0xe6, 0xcc, 0xf2, 0x29, 0xf1, 0x67, 0xd1, 0xf8, 0xca, 0xd0, 0xb9, 0x41, 0xc7, 0xc6, 0xb3, 0x41,
	0x07, 0x7b, 0x75, 0x6a, 0x02, 0xbd, 0x5a, 0x86, 0xb5, 0x4e, 0x52, 0xc4, 0x5e, 0xf5, 0x9a, 0x40,
	0x7a, 0xf9, 0x26, 0xf8, 0x3d, 0x0a, 0xab, 0xde, 0x70, 0xbb, 0x4f, 0x2b, 0x15, 0xcd, 0x22, 0x75,
	0xad, 0x32, 0xc6, 0x1a, 0x9c, 0xc0, 0x72, 0xd1, 0x8b, 0x9b, 0x2f, 0x11, 0x83, 0x56, 0x59, 0x25,
	0x12, 0xd9, 0xad, 0x76, 0x2b, 0xbd, 0xee, 0x18, 0x07, 0x2d, 0x10, 0x5e, 0xf2, 0x97, 0x8e, 0xed,
	0x15, 0xf9, 0x2d, 0x88, 0x55, 0xac, 0x0b, 0xc6, 0x76, 0x22, 0xfb, 0xba, 0x9d, 0xd8, 0x6f, 0xad,
	0xf4, 0x5e, 0x59, 0xb7, 0x3e, 0x68, 0x14, 0x94, 0x22, 0xad, 0xaa, 0xfc, 0xe4, 0xe5, 0xfc, 0x1c,
	0x98, 0xa5, 0x73, 0xd5, 0x6a, 0xd6, 0x88, 0xa9, 0x1c, 0x93, 0x62, 0xbb, 0x95, 0x06, 0x4e, 0x81,
	0x75, 0x81, 0xb0, 0x1d, 0xa8, 0xeb, 0xe8, 0x30, 0x3d, 0x81, 0xa3, 0xc3, 0x17, 0x51, 0xd8, 0x0a,
	0x61, 0xd7, 0x2b, 0xa6, 0xb0, 0x4d, 0x48, 0xe3, 0x9c, 0xf5, 0xd1, 0xf1, 0xce, 0xfa, 0xd8, 0x18,
	0x66, 0xbd, 0xc4, 0x74, 0xe6, 0x0c, 0x9f, 0x17, 0xd3, 0x59, 0x98, 0x90, 0xa2, 0x2f, 0x20, 0xa4,
	0xc7, 0x30, 0x5f, 0x27, 0x35, 0xad, 0xe9, 0x9e, 0x45, 0x63, 0x23, 0x16, 0x5e, 0x74, 0x46, 0x18,
	0xd8, 0x25, 0x3b, 0x8d, 0x0a, 0x85, 0xaf, 0xb0, 0xba, 0x07, 0xb3, 0x15, 0x9b, 0xd8, 0x8d, 0x32,
	0x72, 0x13, 0xbb, 0x8e, 0x08, 0xcf, 0xf0, 0x47, 0xa3, 0x9f, 0x24, 0xb8, 0x95, 0x33, 0xcb, 0xc7,
	0xa4, 0x46, 0x4d, 0xdd, 0x9a, 0x48, 0x17, 0xbf, 0x0d, 0xe0, 0xf3, 0x38, 0xf2, 0x4e, 0xea, 0xbb,
	0x22, 0x2c, 0xc4, 0x11, 0x08, 0x4b, 0xc1, 0x9d, 0xb0, 0x0c, 0x5c, 0xc6, 0xd0, 0x8f, 0x8e, 0x7e,
	0x30, 0x29, 0x11, 0x52, 0xfd, 0x4f, 0x66, 0xb8, 0xcd, 0x24, 0x11, 0x4c, 0xc0, 0x4b, 0xf0, 0x6f,
	0x89, 0x6d, 0xf9, 0x6f, 0xea, 0x1f, 0x36, 0xf4, 0x92, 0x66, 0x91, 0x89, 0xe4, 0xb8, 0x0b, 0xf1,
	0x12, 0x29, 0x58, 0xb4, 0xce, 0x77, 0xe0, 0x80, 0x09, 0xbf, 0x19, 0xa0, 0x62, 0x6a, 0xec, 0x54,
	0x5c, 0x49, 0x90, 0x0a, 0xcf, 0x75, 0x42, 0x1d, 0x22, 0xe7, 0x61, 0x51, 0xd8, 0x19, 0x86, 0xda,
	0x22, 0x03, 0xaf, 0xb7, 0x9d, 0xee, 0x08, 0x2f, 0xf8, 0x0b, 0x8f, 0x1a, 0xd6, 0xbd, 0x67, 0x00,
	0xb1, 0x9c, 0x59, 0x96, 0x3f, 0x95, 0x00, 0x84, 0x97, 0xfb, 0xb4, 0x12, 0xfc, 0xaa, 0xa0, 0x74,
	0xbc, 0x4a, 0x26, 0xef, 0x0e, 0x30, 0xf0, 0xf4, 0xb1, 0xff, 0xd9, 0xcf, 0x7f, 0x3e, 0x89, 0xfe,
	0x5f, 0xfe, 0x9f, 0x1a, 0xf2, 0x09, 0x43, 0x65, 0x3b, 0x6e, 0xa1, 0x99, 0x37, 0xed, 0x87, 0xda,
	0x18, 0x84, 0x97, 0xaa, 0x70, 0x0c, 0xbe, 0x41, 0x0f, 0x0c, 0xdd, 0xef, 0x09, 0x03, 0x30, 0xb0,
	0x37, 0x01, 0x17, 0xc3, 0x27, 0x0c, 0x83, 0x77, 0xb2, 0xee, 0x85, 0xc1, 0x35, 0xe8, 0x89, 0x21,
	0x78, 0x0e, 0x45, 0x19, 0x86, 0x01, 0xc9, 0x3b, 0x3d, 0x30, 0x34, 0xdd, 0x0f, 0x1c, 0xf2, 0xe7,
	0x12, 0xcc, 0x89, 0xc7, 0xca, 0x9d, 0xd0, 0x47, 0x08, 0x16, 0xc9, 0xcc, 0x20, 0x8b, 0x21, 0x99,
	0x30, 0x89, 0xff, 0x9d, 0x45, 0xfe, 0x4e, 0x82, 0xe5, 0xae, 0xe3, 0xd5, 0x6e, 0x9f, 0xb2, 0xfb,
	0x66, 0xc9, 0x83, 0xa1, 0xcc, 0x3c, 0x54, 0x2a, 0x43, 0xb5, 0x2f, 0xdf, 0xed, 0xab, 0x11, 0x5f,
	0xb8, 0x0c, 0x5b, 0xd7, 0x48, 0xde, 0xed, 0x23, 0x87, 0x81, 0xd8, 0x7a, 0x8d, 0xbc, 0x01, 0xd8,
	0x5c, 0xed, 0x08, 0xd8, 0xbe, 0x97, 0x60, 0xa5, 0x7b, 0xa2, 0xed, 0x85, 0x3e, 0xb5, 0xcb, 0x2e,
	0xa9, 0x0c, 0x67, 0x37, 0x24, 0xbc, 0x92, 0xe3, 0x27, 0xc2, 0xfb, 0x56, 0x82, 0xe5, 0xae, 0x69,
	0x14, 0x4e, 0x5d, 0xd0, 0xac, 0x07, 0x75, 0x3d, 0x47, 0x83, 0xc2, 0xb0, 0x65, 0xe4, 0xbd, 0x50,
	0x6c, 0x75, 0xe6, 0x26, 0x42, 0xfb, 0x41, 0x82, 0xd5, 0xb0, 0x39, 0x12, 0x2e, 0xef, 0x10, 0xcb,
	0xe4, 0xab, 0xc3, 0x5a, 0x7a, 0x18, 0x0f, 0x19, 0xc6, 0x57, 0xe4, 0xfd, 0x50, 0x8c, 0x15, 0xd7,
	0x53, 0x80, 0x99, 0x7d, 0xe3, 0xf9, 0x75, 0x4a, 0xba, 0xba, 0x4e, 0x49, 0x7f, 0x5c, 0xa7, 0xa4,
	0xaf, 0x6f, 0x52, 0x91, 0xab, 0x9b, 0x54, 0xe4, 0xd7, 0x9b, 0x54, 0xe4, 0xbd, 0x03, 0xe1, 0x54,
	0xcf, 0xc3, 0x1d, 0x7c, 0x4c, 0x0d, 0xe2, 0xc5, 0xbe, 0xe4, 0xd1, 0xd9, 0x01, 0xbf, 0x10, 0x67,
	0x9f, 0x56, 0x5f, 0xfb, 0x37, 0x00, 0x00, 0xff, 0xff, 0x6c, 0xff, 0x00, 0xe5, 0xdd, 0x15, 0x00,
	0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	// MintBySwap mints Mer stablecoins by swapping in strong-backing assets and
	// Lion coins.
	MintBySwap(ctx context.Context, in *MsgMintBySwap, opts ...grpc.CallOption) (*MsgMintBySwapResponse, error)
	// BurnBySwap burns Mer stablecoins by swapping out strong-backing assets and
	// Lion coins.
	BurnBySwap(ctx context.Context, in *MsgBurnBySwap, opts ...grpc.CallOption) (*MsgBurnBySwapResponse, error)
	// BuyBacking buys strong-backing assets by spending Lion coins.
	BuyBacking(ctx context.Context, in *MsgBuyBacking, opts ...grpc.CallOption) (*MsgBuyBackingResponse, error)
	// SellBacking sells strong-backing assets by earning Lion
	// coins.
	SellBacking(ctx context.Context, in *MsgSellBacking, opts ...grpc.CallOption) (*MsgSellBackingResponse, error)
	// MintByCollateral mints Mer stablecoins by locking collateral assets and
	// spending Lion coins.
	MintByCollateral(ctx context.Context, in *MsgMintByCollateral, opts ...grpc.CallOption) (*MsgMintByCollateralResponse, error)
	// BurnByCollateral burns Mer stablecoins by unlocking collateral assets and
	// earning Lion coins.
	BurnByCollateral(ctx context.Context, in *MsgBurnByCollateral, opts ...grpc.CallOption) (*MsgBurnByCollateralResponse, error)
	// DepositCollateral deposits collateral assets.
	DepositCollateral(ctx context.Context, in *MsgDepositCollateral, opts ...grpc.CallOption) (*MsgDepositCollateralResponse, error)
	// RedeemCollateral redeems collateral assets.
	RedeemCollateral(ctx context.Context, in *MsgRedeemCollateral, opts ...grpc.CallOption) (*MsgRedeemCollateralResponse, error)
	// LiquidateCollateral liquidates collateral assets which is
	// undercollateralized.
	LiquidateCollateral(ctx context.Context, in *MsgLiquidateCollateral, opts ...grpc.CallOption) (*MsgLiquidateCollateralResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) MintBySwap(ctx context.Context, in *MsgMintBySwap, opts ...grpc.CallOption) (*MsgMintBySwapResponse, error) {
	out := new(MsgMintBySwapResponse)
	err := c.cc.Invoke(ctx, "/merlion.maker.v1.Msg/MintBySwap", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) BurnBySwap(ctx context.Context, in *MsgBurnBySwap, opts ...grpc.CallOption) (*MsgBurnBySwapResponse, error) {
	out := new(MsgBurnBySwapResponse)
	err := c.cc.Invoke(ctx, "/merlion.maker.v1.Msg/BurnBySwap", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) BuyBacking(ctx context.Context, in *MsgBuyBacking, opts ...grpc.CallOption) (*MsgBuyBackingResponse, error) {
	out := new(MsgBuyBackingResponse)
	err := c.cc.Invoke(ctx, "/merlion.maker.v1.Msg/BuyBacking", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SellBacking(ctx context.Context, in *MsgSellBacking, opts ...grpc.CallOption) (*MsgSellBackingResponse, error) {
	out := new(MsgSellBackingResponse)
	err := c.cc.Invoke(ctx, "/merlion.maker.v1.Msg/SellBacking", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) MintByCollateral(ctx context.Context, in *MsgMintByCollateral, opts ...grpc.CallOption) (*MsgMintByCollateralResponse, error) {
	out := new(MsgMintByCollateralResponse)
	err := c.cc.Invoke(ctx, "/merlion.maker.v1.Msg/MintByCollateral", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) BurnByCollateral(ctx context.Context, in *MsgBurnByCollateral, opts ...grpc.CallOption) (*MsgBurnByCollateralResponse, error) {
	out := new(MsgBurnByCollateralResponse)
	err := c.cc.Invoke(ctx, "/merlion.maker.v1.Msg/BurnByCollateral", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) DepositCollateral(ctx context.Context, in *MsgDepositCollateral, opts ...grpc.CallOption) (*MsgDepositCollateralResponse, error) {
	out := new(MsgDepositCollateralResponse)
	err := c.cc.Invoke(ctx, "/merlion.maker.v1.Msg/DepositCollateral", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RedeemCollateral(ctx context.Context, in *MsgRedeemCollateral, opts ...grpc.CallOption) (*MsgRedeemCollateralResponse, error) {
	out := new(MsgRedeemCollateralResponse)
	err := c.cc.Invoke(ctx, "/merlion.maker.v1.Msg/RedeemCollateral", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) LiquidateCollateral(ctx context.Context, in *MsgLiquidateCollateral, opts ...grpc.CallOption) (*MsgLiquidateCollateralResponse, error) {
	out := new(MsgLiquidateCollateralResponse)
	err := c.cc.Invoke(ctx, "/merlion.maker.v1.Msg/LiquidateCollateral", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	// MintBySwap mints Mer stablecoins by swapping in strong-backing assets and
	// Lion coins.
	MintBySwap(context.Context, *MsgMintBySwap) (*MsgMintBySwapResponse, error)
	// BurnBySwap burns Mer stablecoins by swapping out strong-backing assets and
	// Lion coins.
	BurnBySwap(context.Context, *MsgBurnBySwap) (*MsgBurnBySwapResponse, error)
	// BuyBacking buys strong-backing assets by spending Lion coins.
	BuyBacking(context.Context, *MsgBuyBacking) (*MsgBuyBackingResponse, error)
	// SellBacking sells strong-backing assets by earning Lion
	// coins.
	SellBacking(context.Context, *MsgSellBacking) (*MsgSellBackingResponse, error)
	// MintByCollateral mints Mer stablecoins by locking collateral assets and
	// spending Lion coins.
	MintByCollateral(context.Context, *MsgMintByCollateral) (*MsgMintByCollateralResponse, error)
	// BurnByCollateral burns Mer stablecoins by unlocking collateral assets and
	// earning Lion coins.
	BurnByCollateral(context.Context, *MsgBurnByCollateral) (*MsgBurnByCollateralResponse, error)
	// DepositCollateral deposits collateral assets.
	DepositCollateral(context.Context, *MsgDepositCollateral) (*MsgDepositCollateralResponse, error)
	// RedeemCollateral redeems collateral assets.
	RedeemCollateral(context.Context, *MsgRedeemCollateral) (*MsgRedeemCollateralResponse, error)
	// LiquidateCollateral liquidates collateral assets which is
	// undercollateralized.
	LiquidateCollateral(context.Context, *MsgLiquidateCollateral) (*MsgLiquidateCollateralResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) MintBySwap(ctx context.Context, req *MsgMintBySwap) (*MsgMintBySwapResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MintBySwap not implemented")
}
func (*UnimplementedMsgServer) BurnBySwap(ctx context.Context, req *MsgBurnBySwap) (*MsgBurnBySwapResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BurnBySwap not implemented")
}
func (*UnimplementedMsgServer) BuyBacking(ctx context.Context, req *MsgBuyBacking) (*MsgBuyBackingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BuyBacking not implemented")
}
func (*UnimplementedMsgServer) SellBacking(ctx context.Context, req *MsgSellBacking) (*MsgSellBackingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SellBacking not implemented")
}
func (*UnimplementedMsgServer) MintByCollateral(ctx context.Context, req *MsgMintByCollateral) (*MsgMintByCollateralResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MintByCollateral not implemented")
}
func (*UnimplementedMsgServer) BurnByCollateral(ctx context.Context, req *MsgBurnByCollateral) (*MsgBurnByCollateralResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BurnByCollateral not implemented")
}
func (*UnimplementedMsgServer) DepositCollateral(ctx context.Context, req *MsgDepositCollateral) (*MsgDepositCollateralResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DepositCollateral not implemented")
}
func (*UnimplementedMsgServer) RedeemCollateral(ctx context.Context, req *MsgRedeemCollateral) (*MsgRedeemCollateralResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RedeemCollateral not implemented")
}
func (*UnimplementedMsgServer) LiquidateCollateral(ctx context.Context, req *MsgLiquidateCollateral) (*MsgLiquidateCollateralResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LiquidateCollateral not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_MintBySwap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgMintBySwap)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).MintBySwap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/merlion.maker.v1.Msg/MintBySwap",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).MintBySwap(ctx, req.(*MsgMintBySwap))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_BurnBySwap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBurnBySwap)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).BurnBySwap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/merlion.maker.v1.Msg/BurnBySwap",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).BurnBySwap(ctx, req.(*MsgBurnBySwap))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_BuyBacking_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBuyBacking)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).BuyBacking(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/merlion.maker.v1.Msg/BuyBacking",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).BuyBacking(ctx, req.(*MsgBuyBacking))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SellBacking_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSellBacking)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SellBacking(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/merlion.maker.v1.Msg/SellBacking",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SellBacking(ctx, req.(*MsgSellBacking))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_MintByCollateral_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgMintByCollateral)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).MintByCollateral(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/merlion.maker.v1.Msg/MintByCollateral",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).MintByCollateral(ctx, req.(*MsgMintByCollateral))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_BurnByCollateral_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBurnByCollateral)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).BurnByCollateral(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/merlion.maker.v1.Msg/BurnByCollateral",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).BurnByCollateral(ctx, req.(*MsgBurnByCollateral))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_DepositCollateral_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDepositCollateral)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).DepositCollateral(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/merlion.maker.v1.Msg/DepositCollateral",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).DepositCollateral(ctx, req.(*MsgDepositCollateral))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RedeemCollateral_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRedeemCollateral)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RedeemCollateral(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/merlion.maker.v1.Msg/RedeemCollateral",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RedeemCollateral(ctx, req.(*MsgRedeemCollateral))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_LiquidateCollateral_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgLiquidateCollateral)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).LiquidateCollateral(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/merlion.maker.v1.Msg/LiquidateCollateral",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).LiquidateCollateral(ctx, req.(*MsgLiquidateCollateral))
	}
	return interceptor(ctx, in, info, handler)
}

var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "merlion.maker.v1.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "MintBySwap",
			Handler:    _Msg_MintBySwap_Handler,
		},
		{
			MethodName: "BurnBySwap",
			Handler:    _Msg_BurnBySwap_Handler,
		},
		{
			MethodName: "BuyBacking",
			Handler:    _Msg_BuyBacking_Handler,
		},
		{
			MethodName: "SellBacking",
			Handler:    _Msg_SellBacking_Handler,
		},
		{
			MethodName: "MintByCollateral",
			Handler:    _Msg_MintByCollateral_Handler,
		},
		{
			MethodName: "BurnByCollateral",
			Handler:    _Msg_BurnByCollateral_Handler,
		},
		{
			MethodName: "DepositCollateral",
			Handler:    _Msg_DepositCollateral_Handler,
		},
		{
			MethodName: "RedeemCollateral",
			Handler:    _Msg_RedeemCollateral_Handler,
		},
		{
			MethodName: "LiquidateCollateral",
			Handler:    _Msg_LiquidateCollateral_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "merlion/maker/v1/tx.proto",
}

func (m *MsgMintBySwap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgMintBySwap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgMintBySwap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.MintOutMin.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size, err := m.LionInMax.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.BackingInMax.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.FullBacking {
		i--
		if m.FullBacking {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintTx(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgMintBySwapResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgMintBySwapResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgMintBySwapResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.MintFee.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.MintOut.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.LionIn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.BackingIn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgBurnBySwap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBurnBySwap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBurnBySwap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.LionOutMin.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.BackingOutMin.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.BurnIn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintTx(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgBurnBySwapResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBurnBySwapResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBurnBySwapResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.LionOut.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.BackingOut.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.BurnFee.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgBuyBacking) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBuyBacking) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBuyBacking) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.BackingOutMin.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.LionIn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintTx(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgBuyBackingResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBuyBackingResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBuyBackingResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.BackingOut.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgSellBacking) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSellBacking) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSellBacking) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.LionOutMin.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.BackingIn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintTx(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSellBackingResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSellBackingResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSellBackingResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.LionOut.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgMintByCollateral) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgMintByCollateral) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgMintByCollateral) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.MintOutMin.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.Ltv.Size()
		i -= size
		if _, err := m.Ltv.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.CollateralDenom) > 0 {
		i -= len(m.CollateralDenom)
		copy(dAtA[i:], m.CollateralDenom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.CollateralDenom)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintTx(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgMintByCollateralResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgMintByCollateralResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgMintByCollateralResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.MintFee.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.MintOut.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.LionIn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgBurnByCollateral) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBurnByCollateral) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBurnByCollateral) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.RepayInMax.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.CollateralDenom) > 0 {
		i -= len(m.CollateralDenom)
		copy(dAtA[i:], m.CollateralDenom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.CollateralDenom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgBurnByCollateralResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBurnByCollateralResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBurnByCollateralResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.RepayIn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgDepositCollateral) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDepositCollateral) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDepositCollateral) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Collateral.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintTx(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgDepositCollateralResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDepositCollateralResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDepositCollateralResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgRedeemCollateral) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRedeemCollateral) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRedeemCollateral) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Collateral.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintTx(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRedeemCollateralResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRedeemCollateralResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRedeemCollateralResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgLiquidateCollateral) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgLiquidateCollateral) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgLiquidateCollateral) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Collateral.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Debtor) > 0 {
		i -= len(m.Debtor)
		copy(dAtA[i:], m.Debtor)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Debtor)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintTx(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgLiquidateCollateralResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgLiquidateCollateralResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgLiquidateCollateralResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.CollateralOut.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.RepayIn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgMintBySwap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.FullBacking {
		n += 2
	}
	l = m.BackingInMax.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.LionInMax.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MintOutMin.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgMintBySwapResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.BackingIn.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.LionIn.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MintOut.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MintFee.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgBurnBySwap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.BurnIn.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.BackingOutMin.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.LionOutMin.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgBurnBySwapResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.BurnFee.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.BackingOut.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.LionOut.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgBuyBacking) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.LionIn.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.BackingOutMin.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgBuyBackingResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.BackingOut.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgSellBacking) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.BackingIn.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.LionOutMin.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgSellBackingResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.LionOut.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgMintByCollateral) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.CollateralDenom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Ltv.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MintOutMin.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgMintByCollateralResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.LionIn.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MintOut.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MintFee.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgBurnByCollateral) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.CollateralDenom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.RepayInMax.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgBurnByCollateralResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RepayIn.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgDepositCollateral) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Collateral.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgDepositCollateralResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgRedeemCollateral) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Collateral.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgRedeemCollateralResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgLiquidateCollateral) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Debtor)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Collateral.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgLiquidateCollateralResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RepayIn.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.CollateralOut.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgMintBySwap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgMintBySwap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgMintBySwap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullBacking", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FullBacking = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackingInMax", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BackingInMax.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LionInMax", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LionInMax.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintOutMin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MintOutMin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgMintBySwapResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgMintBySwapResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgMintBySwapResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackingIn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BackingIn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LionIn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LionIn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintOut", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MintOut.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintFee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MintFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBurnBySwap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBurnBySwap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBurnBySwap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurnIn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BurnIn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackingOutMin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BackingOutMin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LionOutMin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LionOutMin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBurnBySwapResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBurnBySwapResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBurnBySwapResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurnFee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BurnFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackingOut", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BackingOut.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LionOut", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LionOut.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBuyBacking) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBuyBacking: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBuyBacking: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LionIn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LionIn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackingOutMin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BackingOutMin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBuyBackingResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBuyBackingResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBuyBackingResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackingOut", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BackingOut.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSellBacking) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSellBacking: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSellBacking: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackingIn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BackingIn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LionOutMin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LionOutMin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSellBackingResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSellBackingResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSellBackingResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LionOut", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LionOut.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgMintByCollateral) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgMintByCollateral: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgMintByCollateral: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollateralDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollateralDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ltv", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ltv.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintOutMin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MintOutMin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgMintByCollateralResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgMintByCollateralResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgMintByCollateralResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LionIn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LionIn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintOut", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MintOut.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintFee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MintFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBurnByCollateral) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBurnByCollateral: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBurnByCollateral: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollateralDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollateralDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepayInMax", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RepayInMax.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBurnByCollateralResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBurnByCollateralResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBurnByCollateralResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepayIn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RepayIn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDepositCollateral) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDepositCollateral: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDepositCollateral: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collateral", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Collateral.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDepositCollateralResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDepositCollateralResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDepositCollateralResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRedeemCollateral) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRedeemCollateral: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRedeemCollateral: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collateral", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Collateral.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRedeemCollateralResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRedeemCollateralResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRedeemCollateralResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgLiquidateCollateral) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgLiquidateCollateral: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgLiquidateCollateral: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debtor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Debtor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collateral", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Collateral.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgLiquidateCollateralResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgLiquidateCollateralResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgLiquidateCollateralResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepayIn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RepayIn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollateralOut", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollateralOut.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
